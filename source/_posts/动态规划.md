---

title: 动态规划
date: 2018-11-01 22:50:21
categories: "数据结构和算法"
tags:
    - 数据结构
    - 算法
description: 

---

1 动态规划： 将原问题拆解为若干子问题， 同时保存子问题的答案e，使得每个子问题只求解一次，最终获得原问题的姐


通常我们解决的问题是一个递归问题时，就要考虑是否存在重叠子问题，如果存在，采用记忆化搜索（自顶向下,就是我们假设我们已经知道了子问题的解了）或者动态规划（自底向上）  来解决

例子： 斐波那契数列

最容易想到的递归 指数级复杂度
```
int fib(n){
  if(n==0){
    return 0
  }
  if(n==1){
    return 1
  }
  
  return fib(n-1) + fib(n-2)
}
```

可以发现对于求fib(5) 就要求fib(4)+fib(3) 对于fib(3) fib(4)会求一遍fib(3)  fib(3)自身也要求一遍，这就产生了重叠问题 那么为什么不可以在计算过程中将这些值记录下来，下次就可以直接返回，不用重新计算了

## 采用记忆化方法  O（n）复杂度
初始化一个集合  n+1个 默认值都为-1
```
vector<int> v(n+1,-1)
int fib(n){
  if(n==0){
    return 0
  }
  if(n==1){
    return 1
  }
  
  if(v[n] == -1)
      v[n] =  fib(n-1) + fib(n-2)
  return v[n]
}
```

## 采用自底向上的方式（从小问题开始求解 非递归）
```
int fib(n){
  vector<int> v(n+1,-1)
  v[0] = 0
  v[1] = 1
  for(int i=2; i<=n; i++){
     v[i] = v[i-1]+v[i-2]
  }
  reutrn v[n]
}
```

### 问题
有一个楼梯，共有N姐台阶，每一次，可以上一个，也可以上两个，问，爬上这个楼梯，共有多少不同的方法
类比于背包问题，如果我们第一次上一个，那么剩下n-1个台阶要走这个子问题 如果上2个 剩下n-2个台阶要走这个子问题
```
int clime(n){
   if(n==1){
      return 1
   }
   if(n==2){
      return 2
   }
   return clime(n-1) + clime(n-2)
}
```











